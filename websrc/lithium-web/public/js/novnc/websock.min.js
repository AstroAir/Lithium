import*as Log from"./util/logging.min.js";const MAX_RQ_GROW_SIZE=41943040,DataChannel={CONNECTING:"connecting",OPEN:"open",CLOSING:"closing",CLOSED:"closed"},ReadyStates={CONNECTING:[WebSocket.CONNECTING,DataChannel.CONNECTING],OPEN:[WebSocket.OPEN,DataChannel.OPEN],CLOSING:[WebSocket.CLOSING,DataChannel.CLOSING],CLOSED:[WebSocket.CLOSED,DataChannel.CLOSED]},rawChannelProps=["send","close","binaryType","onerror","onmessage","onopen","protocol","readyState"];export default class Websock{constructor(){this._websocket=null,this._rQi=0,this._rQlen=0,this._rQbufferSize=4194304,this._rQ=null,this._sQbufferSize=10240,this._sQlen=0,this._sQ=null,this._eventHandlers={message:()=>{},open:()=>{},close:()=>{},error:()=>{}}}get readyState(){let subState;return null===this._websocket?"unused":(subState=this._websocket.readyState,ReadyStates.CONNECTING.includes(subState)?"connecting":ReadyStates.OPEN.includes(subState)?"open":ReadyStates.CLOSING.includes(subState)?"closing":ReadyStates.CLOSED.includes(subState)?"closed":"unknown")}get sQ(){return this._sQ}get rQ(){return this._rQ}get rQi(){return this._rQi}set rQi(val){this._rQi=val}get rQlen(){return this._rQlen-this._rQi}rQpeek8(){return this._rQ[this._rQi]}rQskipBytes(bytes){this._rQi+=bytes}rQshift8(){return this._rQshift(1)}rQshift16(){return this._rQshift(2)}rQshift32(){return this._rQshift(4)}_rQshift(bytes){let res=0;for(let byte=bytes-1;byte>=0;byte--)res+=this._rQ[this._rQi++]<<8*byte;return res}rQshiftStr(len){void 0===len&&(len=this.rQlen);let str="";for(let i=0;i<len;i+=4096){let part=this.rQshiftBytes(Math.min(4096,len-i));str+=String.fromCharCode.apply(null,part)}return str}rQshiftBytes(len){return void 0===len&&(len=this.rQlen),this._rQi+=len,new Uint8Array(this._rQ.buffer,this._rQi-len,len)}rQshiftTo(target,len){void 0===len&&(len=this.rQlen),target.set(new Uint8Array(this._rQ.buffer,this._rQi,len)),this._rQi+=len}rQslice(start,end=this.rQlen){return new Uint8Array(this._rQ.buffer,this._rQi+start,end-start)}rQwait(msg,num,goback){if(this.rQlen<num){if(goback){if(this._rQi<goback)throw new Error("rQwait cannot backup "+goback+" bytes");this._rQi-=goback}return!0}return!1}flush(){this._sQlen>0&&"open"===this.readyState&&(this._websocket.send(this._encodeMessage()),this._sQlen=0)}send(arr){this._sQ.set(arr,this._sQlen),this._sQlen+=arr.length,this.flush()}sendString(str){this.send(str.split("").map(chr=>chr.charCodeAt(0)))}off(evt){this._eventHandlers[evt]=()=>{}}on(evt,handler){this._eventHandlers[evt]=handler}_allocateBuffers(){this._rQ=new Uint8Array(this._rQbufferSize),this._sQ=new Uint8Array(this._sQbufferSize)}init(){this._allocateBuffers(),this._rQi=0,this._websocket=null}open(uri,protocols){this.attach(new WebSocket(uri,protocols))}attach(rawChannel){this.init();const channelProps=[...Object.keys(rawChannel),...Object.getOwnPropertyNames(Object.getPrototypeOf(rawChannel))];for(let i=0;i<rawChannelProps.length;i++){const prop=rawChannelProps[i];if(channelProps.indexOf(prop)<0)throw new Error("Raw channel missing property: "+prop)}this._websocket=rawChannel,this._websocket.binaryType="arraybuffer",this._websocket.onmessage=this._recvMessage.bind(this),this._websocket.onopen=()=>{Log.Debug(">> WebSock.onopen"),this._websocket.protocol&&Log.Info("Server choose sub-protocol: "+this._websocket.protocol),this._eventHandlers.open(),Log.Debug("<< WebSock.onopen")},this._websocket.onclose=e=>{Log.Debug(">> WebSock.onclose"),this._eventHandlers.close(e),Log.Debug("<< WebSock.onclose")},this._websocket.onerror=e=>{Log.Debug(">> WebSock.onerror: "+e),this._eventHandlers.error(e),Log.Debug("<< WebSock.onerror: "+e)}}close(){this._websocket&&("connecting"!==this.readyState&&"open"!==this.readyState||(Log.Info("Closing WebSocket connection"),this._websocket.close()),this._websocket.onmessage=()=>{})}_encodeMessage(){return new Uint8Array(this._sQ.buffer,0,this._sQlen)}_expandCompactRQ(minFit){const requiredBufferSize=8*(this._rQlen-this._rQi+minFit),resizeNeeded=this._rQbufferSize<requiredBufferSize;if(resizeNeeded&&(this._rQbufferSize=Math.max(2*this._rQbufferSize,requiredBufferSize)),this._rQbufferSize>41943040&&(this._rQbufferSize=41943040,this._rQbufferSize-this.rQlen<minFit))throw new Error("Receive Queue buffer exceeded 41943040 bytes, and the new message could not fit");if(resizeNeeded){const oldRQbuffer=this._rQ.buffer;this._rQ=new Uint8Array(this._rQbufferSize),this._rQ.set(new Uint8Array(oldRQbuffer,this._rQi,this._rQlen-this._rQi))}else this._rQ.copyWithin(0,this._rQi,this._rQlen);this._rQlen=this._rQlen-this._rQi,this._rQi=0}_DecodeMessage(data){const u8=new Uint8Array(data);u8.length>this._rQbufferSize-this._rQlen&&this._expandCompactRQ(u8.length),this._rQ.set(u8,this._rQlen),this._rQlen+=u8.length}_recvMessage(e){this._DecodeMessage(e.data),this.rQlen>0?(this._eventHandlers.message(),this._rQlen==this._rQi&&(this._rQlen=0,this._rQi=0)):Log.Debug("Ignoring empty message")}}