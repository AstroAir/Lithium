import*as Log from"../util/logging.min.js";import Inflator from"../inflator.min.js";export default class TightDecoder{constructor(){this._ctl=null,this._filter=null,this._numColors=0,this._palette=new Uint8Array(1024),this._len=0,this._zlibs=[];for(let i=0;i<4;i++)this._zlibs[i]=new Inflator}decodeRect(x,y,width,height,sock,display,depth){if(null===this._ctl){if(sock.rQwait("TIGHT compression-control",1))return!1;this._ctl=sock.rQshift8();for(let i=0;i<4;i++)this._ctl>>i&1&&(this._zlibs[i].reset(),Log.Info("Reset zlib stream "+i));this._ctl=this._ctl>>4}let ret;if(8===this._ctl)ret=this._fillRect(x,y,width,height,sock,display,depth);else if(9===this._ctl)ret=this._jpegRect(x,y,width,height,sock,display,depth);else if(10===this._ctl)ret=this._pngRect(x,y,width,height,sock,display,depth);else{if(0!=(8&this._ctl))throw new Error("Illegal tight compression received (ctl: "+this._ctl+")");ret=this._basicRect(this._ctl,x,y,width,height,sock,display,depth)}return ret&&(this._ctl=null),ret}_fillRect(x,y,width,height,sock,display,depth){if(sock.rQwait("TIGHT",3))return!1;const rQi=sock.rQi,rQ=sock.rQ;return display.fillRect(x,y,width,height,[rQ[rQi],rQ[rQi+1],rQ[rQi+2]],!1),sock.rQskipBytes(3),!0}_jpegRect(x,y,width,height,sock,display,depth){let data=this._readData(sock);return null!==data&&(display.imageRect(x,y,width,height,"image/jpeg",data),!0)}_pngRect(x,y,width,height,sock,display,depth){throw new Error("PNG received in standard Tight rect")}_basicRect(ctl,x,y,width,height,sock,display,depth){if(null===this._filter)if(4&ctl){if(sock.rQwait("TIGHT",1))return!1;this._filter=sock.rQshift8()}else this._filter=0;let streamId=3&ctl,ret;switch(this._filter){case 0:ret=this._copyFilter(streamId,x,y,width,height,sock,display,depth);break;case 1:ret=this._paletteFilter(streamId,x,y,width,height,sock,display,depth);break;case 2:ret=this._gradientFilter(streamId,x,y,width,height,sock,display,depth);break;default:throw new Error("Illegal tight filter received (ctl: "+this._filter+")")}return ret&&(this._filter=null),ret}_copyFilter(streamId,x,y,width,height,sock,display,depth){const uncompressedSize=width*height*3;let data;if(0===uncompressedSize)return!0;if(uncompressedSize<12){if(sock.rQwait("TIGHT",uncompressedSize))return!1;data=sock.rQshiftBytes(uncompressedSize)}else{if(data=this._readData(sock),null===data)return!1;this._zlibs[streamId].setInput(data),data=this._zlibs[streamId].inflate(uncompressedSize),this._zlibs[streamId].setInput(null)}let rgbx=new Uint8Array(width*height*4);for(let i=0,j=0;i<width*height*4;i+=4,j+=3)rgbx[i]=data[j],rgbx[i+1]=data[j+1],rgbx[i+2]=data[j+2],rgbx[i+3]=255;return display.blitImage(x,y,width,height,rgbx,0,!1),!0}_paletteFilter(streamId,x,y,width,height,sock,display,depth){if(0===this._numColors){if(sock.rQwait("TIGHT palette",1))return!1;const numColors=sock.rQpeek8()+1,paletteSize=3*numColors;if(sock.rQwait("TIGHT palette",1+paletteSize))return!1;this._numColors=numColors,sock.rQskipBytes(1),sock.rQshiftTo(this._palette,paletteSize)}const bpp=this._numColors<=2?1:8,rowSize=Math.floor((width*bpp+7)/8),uncompressedSize=rowSize*height;let data;if(0===uncompressedSize)return!0;if(uncompressedSize<12){if(sock.rQwait("TIGHT",uncompressedSize))return!1;data=sock.rQshiftBytes(uncompressedSize)}else{if(data=this._readData(sock),null===data)return!1;this._zlibs[streamId].setInput(data),data=this._zlibs[streamId].inflate(uncompressedSize),this._zlibs[streamId].setInput(null)}return 2==this._numColors?this._monoRect(x,y,width,height,data,this._palette,display):this._paletteRect(x,y,width,height,data,this._palette,display),this._numColors=0,!0}_monoRect(x,y,width,height,data,palette,display){const dest=this._getScratchBuffer(width*height*4),w=Math.floor((width+7)/8),w1=Math.floor(width/8);for(let y=0;y<height;y++){let dp,sp,x;for(x=0;x<w1;x++)for(let b=7;b>=0;b--)dp=4*(y*width+8*x+7-b),sp=3*(data[y*w+x]>>b&1),dest[dp]=palette[sp],dest[dp+1]=palette[sp+1],dest[dp+2]=palette[sp+2],dest[dp+3]=255;for(let b=7;b>=8-width%8;b--)dp=4*(y*width+8*x+7-b),sp=3*(data[y*w+x]>>b&1),dest[dp]=palette[sp],dest[dp+1]=palette[sp+1],dest[dp+2]=palette[sp+2],dest[dp+3]=255}display.blitImage(x,y,width,height,dest,0,!1)}_paletteRect(x,y,width,height,data,palette,display){const dest=this._getScratchBuffer(width*height*4),total=width*height*4;for(let i=0,j=0;i<total;i+=4,j++){const sp=3*data[j];dest[i]=palette[sp],dest[i+1]=palette[sp+1],dest[i+2]=palette[sp+2],dest[i+3]=255}display.blitImage(x,y,width,height,dest,0,!1)}_gradientFilter(streamId,x,y,width,height,sock,display,depth){throw new Error("Gradient filter not implemented")}_readData(sock){if(0===this._len){if(sock.rQwait("TIGHT",3))return null;let byte;byte=sock.rQshift8(),this._len=127&byte,128&byte&&(byte=sock.rQshift8(),this._len|=(127&byte)<<7,128&byte&&(byte=sock.rQshift8(),this._len|=byte<<14))}if(sock.rQwait("TIGHT",this._len))return null;let data=sock.rQshiftBytes(this._len);return this._len=0,data}_getScratchBuffer(size){return(!this._scratchBuffer||this._scratchBuffer.length<size)&&(this._scratchBuffer=new Uint8Array(size)),this._scratchBuffer}}