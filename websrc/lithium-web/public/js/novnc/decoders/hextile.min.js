import*as Log from"../util/logging.min.js";export default class HextileDecoder{constructor(){this._tiles=0,this._lastsubencoding=0,this._tileBuffer=new Uint8Array(1024)}decodeRect(x,y,width,height,sock,display,depth){for(0===this._tiles&&(this._tilesX=Math.ceil(width/16),this._tilesY=Math.ceil(height/16),this._totalTiles=this._tilesX*this._tilesY,this._tiles=this._totalTiles);this._tiles>0;){let bytes=1;if(sock.rQwait("HEXTILE",bytes))return!1;let rQ=sock.rQ,rQi=sock.rQi,subencoding=rQ[rQi];if(subencoding>30)throw new Error("Illegal hextile subencoding (subencoding: "+subencoding+")");const currTile=this._totalTiles-this._tiles,tileX=currTile%this._tilesX,tileY=Math.floor(currTile/this._tilesX),tx=x+16*tileX,ty=y+16*tileY,tw=Math.min(16,x+width-tx),th=Math.min(16,y+height-ty);if(1&subencoding)bytes+=tw*th*4;else if(2&subencoding&&(bytes+=4),4&subencoding&&(bytes+=4),8&subencoding){if(bytes++,sock.rQwait("HEXTILE",bytes))return!1;let subrects=rQ[rQi+bytes-1];bytes+=16&subencoding?6*subrects:2*subrects}if(sock.rQwait("HEXTILE",bytes))return!1;if(rQi++,0===subencoding)1&this._lastsubencoding?Log.Debug("     Ignoring blank after RAW"):display.fillRect(tx,ty,tw,th,this._background);else if(1&subencoding){let pixels=tw*th;for(let i=0;i<pixels;i++)rQ[rQi+4*i+3]=255;display.blitImage(tx,ty,tw,th,rQ,rQi),rQi+=bytes-1}else{if(2&subencoding&&(this._background=[rQ[rQi],rQ[rQi+1],rQ[rQi+2],rQ[rQi+3]],rQi+=4),4&subencoding&&(this._foreground=[rQ[rQi],rQ[rQi+1],rQ[rQi+2],rQ[rQi+3]],rQi+=4),this._startTile(tx,ty,tw,th,this._background),8&subencoding){let subrects=rQ[rQi];rQi++;for(let s=0;s<subrects;s++){let color;16&subencoding?(color=[rQ[rQi],rQ[rQi+1],rQ[rQi+2],rQ[rQi+3]],rQi+=4):color=this._foreground;const xy=rQ[rQi];rQi++;const sx=xy>>4,sy=15&xy,wh=rQ[rQi];rQi++;const sw=1+(wh>>4),sh=1+(15&wh);this._subTile(sx,sy,sw,sh,color)}}this._finishTile(display)}sock.rQi=rQi,this._lastsubencoding=subencoding,this._tiles--}return!0}_startTile(x,y,width,height,color){this._tileX=x,this._tileY=y,this._tileW=width,this._tileH=height;const red=color[0],green=color[1],blue=color[2],data=this._tileBuffer;for(let i=0;i<width*height*4;i+=4)data[i]=red,data[i+1]=green,data[i+2]=blue,data[i+3]=255}_subTile(x,y,w,h,color){const red=color[0],green=color[1],blue=color[2],xend=x+w,yend=y+h,data=this._tileBuffer,width=this._tileW;for(let j=y;j<yend;j++)for(let i=x;i<xend;i++){const p=4*(i+j*width);data[p]=red,data[p+1]=green,data[p+2]=blue,data[p+3]=255}}_finishTile(display){display.blitImage(this._tileX,this._tileY,this._tileW,this._tileH,this._tileBuffer,0)}}