import Inflate from"../inflator.min.js";const ZRLE_TILE_WIDTH=64,ZRLE_TILE_HEIGHT=64;export default class ZRLEDecoder{constructor(){this._length=0,this._inflator=new Inflate,this._pixelBuffer=new Uint8Array(16384),this._tileBuffer=new Uint8Array(16384)}decodeRect(x,y,width,height,sock,display,depth){if(0===this._length){if(sock.rQwait("ZLib data length",4))return!1;this._length=sock.rQshift32()}if(sock.rQwait("Zlib data",this._length))return!1;const data=sock.rQshiftBytes(this._length);this._inflator.setInput(data);for(let ty=y;ty<y+height;ty+=64){let th=Math.min(64,y+height-ty);for(let tx=x;tx<x+width;tx+=64){let tw=Math.min(64,x+width-tx);const tileSize=tw*th,subencoding=this._inflator.inflate(1)[0];if(0===subencoding){const data=this._readPixels(tileSize);display.blitImage(tx,ty,tw,th,data,0,!1)}else if(1===subencoding){const background=this._readPixels(1);display.fillRect(tx,ty,tw,th,[background[0],background[1],background[2]])}else if(subencoding>=2&&subencoding<=16){const data=this._decodePaletteTile(subencoding,tileSize,tw,th);display.blitImage(tx,ty,tw,th,data,0,!1)}else if(128===subencoding){const data=this._decodeRLETile(tileSize);display.blitImage(tx,ty,tw,th,data,0,!1)}else{if(!(subencoding>=130&&subencoding<=255))throw new Error("Unknown subencoding: "+subencoding);{const data=this._decodeRLEPaletteTile(subencoding-128,tileSize);display.blitImage(tx,ty,tw,th,data,0,!1)}}}}return this._length=0,!0}_getBitsPerPixelInPalette(paletteSize){return paletteSize<=2?1:paletteSize<=4?2:paletteSize<=16?4:void 0}_readPixels(pixels){let data=this._pixelBuffer;const buffer=this._inflator.inflate(3*pixels);for(let i=0,j=0;i<4*pixels;i+=4,j+=3)data[i]=buffer[j],data[i+1]=buffer[j+1],data[i+2]=buffer[j+2],data[i+3]=255;return data}_decodePaletteTile(paletteSize,tileSize,tilew,tileh){const data=this._tileBuffer,palette=this._readPixels(paletteSize),bitsPerPixel=this._getBitsPerPixelInPalette(paletteSize),mask=(1<<bitsPerPixel)-1;let offset=0,encoded=this._inflator.inflate(1)[0];for(let y=0;y<tileh;y++){let shift=8-bitsPerPixel;for(let x=0;x<tilew;x++){shift<0&&(shift=8-bitsPerPixel,encoded=this._inflator.inflate(1)[0]);let indexInPalette=encoded>>shift&mask;data[offset]=palette[4*indexInPalette],data[offset+1]=palette[4*indexInPalette+1],data[offset+2]=palette[4*indexInPalette+2],data[offset+3]=palette[4*indexInPalette+3],offset+=4,shift-=bitsPerPixel}shift<8-bitsPerPixel&&y<tileh-1&&(encoded=this._inflator.inflate(1)[0])}return data}_decodeRLETile(tileSize){const data=this._tileBuffer;let i=0;for(;i<tileSize;){const pixel=this._readPixels(1),length=this._readRLELength();for(let j=0;j<length;j++)data[4*i]=pixel[0],data[4*i+1]=pixel[1],data[4*i+2]=pixel[2],data[4*i+3]=pixel[3],i++}return data}_decodeRLEPaletteTile(paletteSize,tileSize){const data=this._tileBuffer,palette=this._readPixels(paletteSize);let offset=0;for(;offset<tileSize;){let indexInPalette=this._inflator.inflate(1)[0],length=1;if(indexInPalette>=128&&(indexInPalette-=128,length=this._readRLELength()),indexInPalette>paletteSize)throw new Error("Too big index in palette: "+indexInPalette+", palette size: "+paletteSize);if(offset+length>tileSize)throw new Error("Too big rle length in palette mode: "+length+", allowed length is: "+(tileSize-offset));for(let j=0;j<length;j++)data[4*offset]=palette[4*indexInPalette],data[4*offset+1]=palette[4*indexInPalette+1],data[4*offset+2]=palette[4*indexInPalette+2],data[4*offset+3]=palette[4*indexInPalette+3],offset++}return data}_readRLELength(){let length=0,current=0;do{current=this._inflator.inflate(1)[0],length+=current}while(255===current);return length+1}}