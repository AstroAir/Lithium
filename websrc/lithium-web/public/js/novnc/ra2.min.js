import Base64 from"./base64.min.js";import{encodeUTF8}from"./util/strings.min.js";import EventTargetMixin from"./util/eventtarget.min.js";export class AESEAXCipher{constructor(){this._rawKey=null,this._ctrKey=null,this._cbcKey=null,this._zeroBlock=new Uint8Array(16),this._prefixBlock0=this._zeroBlock,this._prefixBlock1=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]),this._prefixBlock2=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2])}async _encryptBlock(block){const encrypted=await window.crypto.subtle.encrypt({name:"AES-CBC",iv:this._zeroBlock},this._cbcKey,block);return new Uint8Array(encrypted).slice(0,16)}async _initCMAC(){const k1=await this._encryptBlock(this._zeroBlock),k2=new Uint8Array(16),v=k1[0]>>>6;for(let i=0;i<15;i++)k2[i]=k1[i+1]>>6|k1[i]<<2,k1[i]=k1[i+1]>>7|k1[i]<<1;const lut=[0,135,14,137];k2[14]^=v>>>1,k2[15]=k1[15]<<2^lut[v],k1[15]=k1[15]<<1^lut[v>>1],this._k1=k1,this._k2=k2}async _encryptCTR(data,counter){const encrypted=await window.crypto.subtle.encrypt({name:"AES-CTR",counter:counter,length:128},this._ctrKey,data);return new Uint8Array(encrypted)}async _decryptCTR(data,counter){const decrypted=await window.crypto.subtle.decrypt({name:"AES-CTR",counter:counter,length:128},this._ctrKey,data);return new Uint8Array(decrypted)}async _computeCMAC(data,prefixBlock){if(16!==prefixBlock.length)return null;const n=Math.floor(data.length/16),m=Math.ceil(data.length/16),r=data.length-16*n,cbcData=new Uint8Array(16*(m+1));if(cbcData.set(prefixBlock),cbcData.set(data,16),0===r)for(let i=0;i<16;i++)cbcData[16*n+i]^=this._k1[i];else{cbcData[16*(n+1)+r]=128;for(let i=0;i<16;i++)cbcData[16*(n+1)+i]^=this._k2[i]}let cbcEncrypted=await window.crypto.subtle.encrypt({name:"AES-CBC",iv:this._zeroBlock},this._cbcKey,cbcData);cbcEncrypted=new Uint8Array(cbcEncrypted);const mac=cbcEncrypted.slice(cbcEncrypted.length-32,cbcEncrypted.length-16);return mac}async setKey(key){this._rawKey=key,this._ctrKey=await window.crypto.subtle.importKey("raw",key,{name:"AES-CTR"},!1,["encrypt","decrypt"]),this._cbcKey=await window.crypto.subtle.importKey("raw",key,{name:"AES-CBC"},!1,["encrypt","decrypt"]),await this._initCMAC()}async encrypt(message,associatedData,nonce){const nCMAC=await this._computeCMAC(nonce,this._prefixBlock0),encrypted=await this._encryptCTR(message,nCMAC),adCMAC=await this._computeCMAC(associatedData,this._prefixBlock1),mac=await this._computeCMAC(encrypted,this._prefixBlock2);for(let i=0;i<16;i++)mac[i]^=nCMAC[i]^adCMAC[i];const res=new Uint8Array(16+encrypted.length);return res.set(encrypted),res.set(mac,encrypted.length),res}async decrypt(encrypted,associatedData,nonce,mac){const nCMAC=await this._computeCMAC(nonce,this._prefixBlock0),adCMAC=await this._computeCMAC(associatedData,this._prefixBlock1),computedMac=await this._computeCMAC(encrypted,this._prefixBlock2);for(let i=0;i<16;i++)computedMac[i]^=nCMAC[i]^adCMAC[i];if(computedMac.length!==mac.length)return null;for(let i=0;i<mac.length;i++)if(computedMac[i]!==mac[i])return null;const res=await this._decryptCTR(encrypted,nCMAC);return res}}export class RA2Cipher{constructor(){this._cipher=new AESEAXCipher,this._counter=new Uint8Array(16)}async setKey(key){await this._cipher.setKey(key)}async makeMessage(message){const ad=new Uint8Array([(65280&message.length)>>>8,255&message.length]),encrypted=await this._cipher.encrypt(message,ad,this._counter);for(let i=0;i<16&&255==this._counter[i]++;i++);const res=new Uint8Array(message.length+2+16);return res.set(ad),res.set(encrypted,2),res}async receiveMessage(length,encrypted,mac){const ad=new Uint8Array([(65280&length)>>>8,255&length]),res=await this._cipher.decrypt(encrypted,ad,this._counter,mac);for(let i=0;i<16&&255==this._counter[i]++;i++);return res}}export class RSACipher{constructor(keyLength){this._key=null,this._keyLength=keyLength,this._keyBytes=Math.ceil(keyLength/8),this._n=null,this._e=null,this._d=null,this._nBigInt=null,this._eBigInt=null,this._dBigInt=null}_base64urlDecode(data){return data=(data=data.replace(/-/g,"+").replace(/_/g,"/")).padEnd(4*Math.ceil(data.length/4),"="),Base64.decode(data)}_u8ArrayToBigInt(arr){let hex="0x";for(let i=0;i<arr.length;i++)hex+=arr[i].toString(16).padStart(2,"0");return BigInt(hex)}_padArray(arr,length){const res=new Uint8Array(length);return res.set(arr,length-arr.length),res}_bigIntToU8Array(bigint,padLength=0){let hex=bigint.toString(16);0===padLength&&(padLength=2*Math.ceil(hex.length/2)),hex=hex.padStart(2*padLength,"0");const length=hex.length/2,arr=new Uint8Array(length);for(let i=0;i<length;i++)arr[i]=parseInt(hex.slice(2*i,2*i+2),16);return arr}_modPow(b,e,m){if(1n===m)return 0;let r=1n;for(b%=m;e>0;)e%2n===1n&&(r=r*b%m),e/=2n,b=b*b%m;return r}async generateKey(){this._key=await window.crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:this._keyLength,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["encrypt","decrypt"]);const privateKey=await window.crypto.subtle.exportKey("jwk",this._key.privateKey);this._n=this._padArray(this._base64urlDecode(privateKey.n),this._keyBytes),this._nBigInt=this._u8ArrayToBigInt(this._n),this._e=this._padArray(this._base64urlDecode(privateKey.e),this._keyBytes),this._eBigInt=this._u8ArrayToBigInt(this._e),this._d=this._padArray(this._base64urlDecode(privateKey.d),this._keyBytes),this._dBigInt=this._u8ArrayToBigInt(this._d)}setPublicKey(n,e){n.length===this._keyBytes&&e.length===this._keyBytes&&(this._n=new Uint8Array(this._keyBytes),this._e=new Uint8Array(this._keyBytes),this._n.set(n),this._e.set(e),this._nBigInt=this._u8ArrayToBigInt(this._n),this._eBigInt=this._u8ArrayToBigInt(this._e))}encrypt(message){if(message.length>this._keyBytes-11)return null;const ps=new Uint8Array(this._keyBytes-message.length-3);window.crypto.getRandomValues(ps);for(let i=0;i<ps.length;i++)ps[i]=Math.floor(254*ps[i]/255+1);const em=new Uint8Array(this._keyBytes);em[1]=2,em.set(ps,2),em.set(message,ps.length+3);const emBigInt=this._u8ArrayToBigInt(em),c=this._modPow(emBigInt,this._eBigInt,this._nBigInt);return this._bigIntToU8Array(c,this._keyBytes)}decrypt(message){if(message.length!==this._keyBytes)return null;const msgBigInt=this._u8ArrayToBigInt(message),emBigInt=this._modPow(msgBigInt,this._dBigInt,this._nBigInt),em=this._bigIntToU8Array(emBigInt,this._keyBytes);if(0!==em[0]||2!==em[1])return null;let i=2;for(;i<em.length&&0!==em[i];i++);return i===em.length?null:em.slice(i+1,em.length)}get keyLength(){return this._keyLength}get n(){return this._n}get e(){return this._e}get d(){return this._d}}export default class RSAAESAuthenticationState extends EventTargetMixin{constructor(sock,getCredentials){super(),this._hasStarted=!1,this._checkSock=null,this._checkCredentials=null,this._approveServerResolve=null,this._sockReject=null,this._credentialsReject=null,this._approveServerReject=null,this._sock=sock,this._getCredentials=getCredentials}_waitSockAsync(len){return new Promise((resolve,reject)=>{const hasData=()=>!this._sock.rQwait("RA2",len);hasData()?resolve():(this._checkSock=()=>{hasData()&&(resolve(),this._checkSock=null,this._sockReject=null)},this._sockReject=reject)})}_waitApproveKeyAsync(){return new Promise((resolve,reject)=>{this._approveServerResolve=resolve,this._approveServerReject=reject})}_waitCredentialsAsync(subtype){const hasCredentials=()=>1===subtype&&void 0!==this._getCredentials().username&&void 0!==this._getCredentials().password||2===subtype&&void 0!==this._getCredentials().password;return new Promise((resolve,reject)=>{hasCredentials()?resolve():(this._checkCredentials=()=>{hasCredentials()&&(resolve(),this._checkCredentials=null,this._credentialsReject=null)},this._credentialsReject=reject)})}checkInternalEvents(){null!==this._checkSock&&this._checkSock(),null!==this._checkCredentials&&this._checkCredentials()}approveServer(){null!==this._approveServerResolve&&(this._approveServerResolve(),this._approveServerResolve=null)}disconnect(){null!==this._sockReject&&(this._sockReject(new Error("disconnect normally")),this._sockReject=null),null!==this._credentialsReject&&(this._credentialsReject(new Error("disconnect normally")),this._credentialsReject=null),null!==this._approveServerReject&&(this._approveServerReject(new Error("disconnect normally")),this._approveServerReject=null)}async negotiateRA2neAuthAsync(){this._hasStarted=!0,await this._waitSockAsync(4);const serverKeyLengthBuffer=this._sock.rQslice(0,4),serverKeyLength=this._sock.rQshift32();if(serverKeyLength<1024)throw new Error("RA2: server public key is too short: "+serverKeyLength);if(serverKeyLength>8192)throw new Error("RA2: server public key is too long: "+serverKeyLength);const serverKeyBytes=Math.ceil(serverKeyLength/8);await this._waitSockAsync(2*serverKeyBytes);const serverN=this._sock.rQshiftBytes(serverKeyBytes),serverE=this._sock.rQshiftBytes(serverKeyBytes),serverRSACipher=new RSACipher(serverKeyLength);serverRSACipher.setPublicKey(serverN,serverE);const serverPublickey=new Uint8Array(4+2*serverKeyBytes);serverPublickey.set(serverKeyLengthBuffer),serverPublickey.set(serverN,4),serverPublickey.set(serverE,4+serverKeyBytes),this.dispatchEvent(new CustomEvent("serververification",{detail:{type:"RSA",publickey:serverPublickey}})),await this._waitApproveKeyAsync();const clientKeyLength=2048,clientKeyBytes=Math.ceil(256),clientRSACipher=new RSACipher(2048);await clientRSACipher.generateKey();const clientN=clientRSACipher.n,clientE=clientRSACipher.e,clientPublicKey=new Uint8Array(4+2*clientKeyBytes);clientPublicKey[0]=0,clientPublicKey[1]=0,clientPublicKey[2]=8,clientPublicKey[3]=0,clientPublicKey.set(clientN,4),clientPublicKey.set(clientE,4+clientKeyBytes),this._sock.send(clientPublicKey);const clientRandom=new Uint8Array(16);window.crypto.getRandomValues(clientRandom);const clientEncryptedRandom=serverRSACipher.encrypt(clientRandom),clientRandomMessage=new Uint8Array(2+serverKeyBytes);if(clientRandomMessage[0]=(65280&serverKeyBytes)>>>8,clientRandomMessage[1]=255&serverKeyBytes,clientRandomMessage.set(clientEncryptedRandom,2),this._sock.send(clientRandomMessage),await this._waitSockAsync(2),this._sock.rQshift16()!==clientKeyBytes)throw new Error("RA2: wrong encrypted message length");const serverEncryptedRandom=this._sock.rQshiftBytes(clientKeyBytes),serverRandom=clientRSACipher.decrypt(serverEncryptedRandom);if(null===serverRandom||16!==serverRandom.length)throw new Error("RA2: corrupted server encrypted random");let clientSessionKey=new Uint8Array(32),serverSessionKey=new Uint8Array(32);clientSessionKey.set(serverRandom),clientSessionKey.set(clientRandom,16),serverSessionKey.set(clientRandom),serverSessionKey.set(serverRandom,16),clientSessionKey=await window.crypto.subtle.digest("SHA-1",clientSessionKey),clientSessionKey=new Uint8Array(clientSessionKey).slice(0,16),serverSessionKey=await window.crypto.subtle.digest("SHA-1",serverSessionKey),serverSessionKey=new Uint8Array(serverSessionKey).slice(0,16);const clientCipher=new RA2Cipher;await clientCipher.setKey(clientSessionKey);const serverCipher=new RA2Cipher;await serverCipher.setKey(serverSessionKey);let serverHash=new Uint8Array(8+2*serverKeyBytes+2*clientKeyBytes),clientHash=new Uint8Array(8+2*serverKeyBytes+2*clientKeyBytes);if(serverHash.set(serverPublickey),serverHash.set(clientPublicKey,4+2*serverKeyBytes),clientHash.set(clientPublicKey),clientHash.set(serverPublickey,4+2*clientKeyBytes),serverHash=await window.crypto.subtle.digest("SHA-1",serverHash),clientHash=await window.crypto.subtle.digest("SHA-1",clientHash),serverHash=new Uint8Array(serverHash),clientHash=new Uint8Array(clientHash),this._sock.send(await clientCipher.makeMessage(clientHash)),await this._waitSockAsync(38),20!==this._sock.rQshift16())throw new Error("RA2: wrong server hash");const serverHashReceived=await serverCipher.receiveMessage(20,this._sock.rQshiftBytes(20),this._sock.rQshiftBytes(16));if(null===serverHashReceived)throw new Error("RA2: failed to authenticate the message");for(let i=0;i<20;i++)if(serverHashReceived[i]!==serverHash[i])throw new Error("RA2: wrong server hash");if(await this._waitSockAsync(19),1!==this._sock.rQshift16())throw new Error("RA2: wrong subtype");let subtype=await serverCipher.receiveMessage(1,this._sock.rQshiftBytes(1),this._sock.rQshiftBytes(16)),username;if(null===subtype)throw new Error("RA2: failed to authenticate the message");if(subtype=subtype[0],1===subtype)void 0!==this._getCredentials().username&&void 0!==this._getCredentials().password||this.dispatchEvent(new CustomEvent("credentialsrequired",{detail:{types:["username","password"]}}));else{if(2!==subtype)throw new Error("RA2: wrong subtype");void 0===this._getCredentials().password&&this.dispatchEvent(new CustomEvent("credentialsrequired",{detail:{types:["password"]}}))}await this._waitCredentialsAsync(subtype),username=1===subtype?encodeUTF8(this._getCredentials().username).slice(0,255):"";const password=encodeUTF8(this._getCredentials().password).slice(0,255),credentials=new Uint8Array(username.length+password.length+2);credentials[0]=username.length,credentials[username.length+1]=password.length;for(let i=0;i<username.length;i++)credentials[i+1]=username.charCodeAt(i);for(let i=0;i<password.length;i++)credentials[username.length+2+i]=password.charCodeAt(i);this._sock.send(await clientCipher.makeMessage(credentials))}get hasStarted(){return this._hasStarted}set hasStarted(s){this._hasStarted=s}}