"""
C++ Template Error Analyzer

This script provides tools to analyze and visualize complex C++ template errors, especially those
generated by compilers like GCC, Clang, or MSVC. By parsing error logs from these compilers,
the script can extract key error information, suggest possible fixes, and even generate a visual
representation of the error hierarchy using Graphviz.

Key Features:
1. **Error Parsing**: The script identifies the main error, nested template instantiation errors,
   and other key details like "no matching function" or "substitution failure".
2. **Suggestions**: For common error patterns, the tool generates suggestions on how to address
   the problem, such as reviewing template parameters or checking function signatures.
3. **Code Context Extraction**: Automatically extracts and highlights relevant lines of code
   from the source file where the error occurred, helping users to quickly locate and understand
   the error in context.
4. **Error Visualization**: Uses Graphviz to create a visual tree of the error, showing the main
   error and its nested instantiations. This helps developers visualize the relationships between
   template instantiations.
5. **File Handling**: Supports downloading error log files from a URL and decompressing gzip files
   to handle various types of logs and archives.
6. **Error Information Export**: Saves the parsed error details to a JSON file for later review or
   integration with other tools.

Usage:
------

### Basic Example:
To analyze an error log file and generate a visual error tree:

```bash
python error_analyzer.py error_log.txt --graph error_tree --format png --view
```
This will:
Parse the error_log.txt file to extract error information.
Save the parsed information as parsed_error.json.
Generate an error tree visualization (error_tree.png).
Open the generated image for viewing if the --view flag is provided.

Extract Code Context:

To also extract the source code lines around the error:
bash
python error_analyzer.py error_log.txt --context 5

This will:
Parse the error_log.txt file.
Extract 5 lines of code before and after the error location and display them.

Download and Analyze:

If the error log is hosted online, you can download it first and then analyze:
bash
python error_analyzer.py downloaded_log.txt --download http://example.com/error_log.txt

This will:
Download the error log file from the provided URL.
Parse the error and save the results.

Decompress and Analyze:

To analyze a compressed (gzip) error log:
bash
python error_analyzer.py decompressed_error.txt --decompress error_log.txt.gz

This will:
Decompress error_log.txt.gz and save it as decompressed_error.txt.
Parse the decompressed error log.

Available Command-Line Options:

bash
usage: error_analyzer.py [-h] [--output OUTPUT] [--graph GRAPH] [--compiler COMPILER] [--context CONTEXT]
                         [--download URL] [--decompress GZIP_FILE] [--format FORMAT] [--view] [--no-save]
                         FILE

C++ Template Error Analyzer

positional arguments:
  FILE                  Path to the error log file

optional arguments:
  -h, --help            Show this help message and exit
  --output OUTPUT       Path to save parsed error info (default: "parsed_error.json")
  --graph GRAPH         Filename for error tree graph (default: "error_tree")
  --compiler COMPILER   Compiler type (gcc, clang, msvc) (default: gcc)
  --context CONTEXT     Number of context lines to extract around error line (default: 3)
  --download URL        URL to download the error log file
  --decompress GZIP_FILE
                        Path to the gzip file to decompress
  --format FORMAT       Format of the output graph file (e.g., 'png', 'pdf') (default: png)
  --view                Whether to open the generated graph file with the default viewer
  --no-save             Skip saving the generated graph file
bash

How the Script Works:

Error Parsing:
The script reads the provided error log file and matches common error patterns.
It identifies the main error and nested instantiations, and gathers error details like mismatched types or failed substitutions.
Code Context:
If a source file and line number are available in the error log, the script will extract a number of lines around the error to provide context.
Suggestions:
Based on the error details, the script generates suggestions such as checking template parameters or ensuring that the function signatures match.
Error Tree Generation:
A visual representation of the error hierarchy is created using Graphviz. The main error is shown as the root, with nested template instantiations as child nodes. This graph can be saved in various formats (e.g., PNG, PDF) and viewed immediately if requested.
Saving Output:
The parsed error information is saved to a JSON file, which can be used for further analysis or shared with other developers.

Dependencies:

This script relies on several Python libraries, which can be installed using pip:
bash
pip install requests termcolor graphviz argparse

For Graphviz rendering, ensure that the Graphviz command-line tools are installed and available in your system's PATH. You can download Graphviz from: https://graphviz.org/download/
Example Error:

Suppose you have the following error log in error_log.txt:
main.cpp:15:10: error: no matching function for call to 'foo'
note: candidate function template not viable: no known conversion from 'int' to 'std::string' for 1st argument

Running the following command:
bash
python error_analyzer.py error_log.txt --context 5 --graph error_tree --view

Will output:
Parsed error details with suggestions like "Check the function signature and ensure template parameters match".
A graphical error tree visualizing the error's structure.
The code context around the line where the error occurred.

"""

import re
import argparse
import json
import graphviz
import gzip
import requests
from termcolor import colored
from pathlib import Path


def parse_cpp_template_error(error_message, compiler='gcc'):
    """
    Parses a C++ template error message and returns a structured representation.
    Args:
        error_message (str): The error message from the C++ compiler.
        compiler (str): The compiler type (gcc, clang, msvc).
    Returns:
        dict: A dictionary containing the parsed error information.
    """
    error_info = {
        "main_error": None,
        "nested_errors": [],
        "error_details": [],
        "suggestions": []
    }

    # Patterns for matching main error, nested errors, and template instantiations
    main_error_pattern = re.compile(r'^(.*?):(\d+):(\d+): error: (.*)') if compiler in [
        'gcc', 'clang'] else re.compile(r'.*error C\d+: (.*)')
    nested_error_pattern = re.compile(
        r'note: in instantiation of (.*) requested here')
    template_error_pattern = re.compile(
        r'.*?(\bno matching function\b|\bsubstitution failure\b|\binvalid type\b|.*\bnot viable\b|.*\bdoes not match\b|.*\bredefinition\b).*')

    # Split lines and parse main error
    lines = error_message.splitlines()
    for line in lines:
        main_error_match = main_error_pattern.match(line)
        if main_error_match:
            if compiler in ['gcc', 'clang']:
                file, line_no, col_no, error_text = main_error_match.groups()
                error_info["main_error"] = {
                    "file": file,
                    "line": line_no,
                    "column": col_no,
                    "message": error_text
                }
            else:
                error_info["main_error"] = {
                    "message": main_error_match.group(1)
                }

        nested_match = nested_error_pattern.search(line)
        if nested_match:
            error_info["nested_errors"].append(nested_match.group(1))

        detail_match = template_error_pattern.search(line)
        if detail_match:
            error_info["error_details"].append(detail_match.group())

    # Generate suggestions based on common errors
    generate_suggestions(error_info)

    return error_info


def generate_suggestions(error_info):
    """
    Generate suggestions based on parsed error details.
    Args:
        error_info (dict): The parsed error information.
    """
    suggestions = {
        'no matching function': "Check the function signature and ensure template parameters match.",
        'substitution failure': "Review the template parameters and constraints for compatibility.",
        'invalid type': "Ensure the types used in template instantiation are valid and correctly defined.",
        'not viable': "Check if the candidate functions or templates are properly overloaded or specialized.",
        'does not match': "Ensure the types or arguments provided match the function or template signature.",
        'redefinition': "There might be a redefinition of a function, variable or template. Ensure unique names."
    }

    for detail in error_info["error_details"]:
        for key, suggestion in suggestions.items():
            if key in detail:
                error_info["suggestions"].append(suggestion)


def format_error(error_info):
    """
    Formats and prints the parsed error information in a readable format.
    Args:
        error_info (dict): The parsed error information.
    """
    main_error = error_info["main_error"]
    if main_error:
        print(colored("Main Error:", 'red'))
        if 'file' in main_error:
            print(f"  {colored('File:', 'cyan')} {main_error['file']}")
            print(f"  {colored('Line:', 'cyan')} {main_error['line']}, {
                  colored('Column:', 'cyan')} {main_error['column']}")
        print(f"  {colored('Message:', 'yellow')} {main_error['message']}\n")

    if error_info['nested_errors']:
        print(colored("Nested Errors:", 'red'))
        for idx, nested in enumerate(error_info['nested_errors'], 1):
            print(f"  {idx}. {colored(nested, 'green')}")

    if error_info['error_details']:
        print(colored("\nError Details:", 'red'))
        for detail in error_info['error_details']:
            print(f"  {colored(detail, 'magenta')}")

    if error_info['suggestions']:
        print(colored("\nSuggestions:", 'red'))
        for suggestion in error_info['suggestions']:
            print(f"  {colored('- ' + suggestion, 'blue')}")


def extract_code_context(file_path, line_number, context_lines=3):
    """
    Extracts context lines from the source code file around the specified line number.
    Args:
        file_path (str): Path to the source file.
        line_number (int): Line number where the error occurred.
        context_lines (int): Number of lines to extract before and after the error line.
    Returns:
        str: The extracted code context.
    """
    try:
        with open(file_path, 'r') as file:
            lines = file.readlines()
            start = max(0, line_number - context_lines - 1)
            end = min(len(lines), line_number + context_lines)
            context = ''.join(lines[start:end])
            context = highlight_error_line(context, line_number - start)
            return context
    except Exception as e:
        print(colored(f"Error reading file: {e}", 'red'))
        return ""


def highlight_error_line(context, error_line_index):
    """
    Highlights the error line in the extracted code context.
    Args:
        context (str): The extracted code context.
        error_line_index (int): The index of the error line.
    Returns:
        str: The context with the error line highlighted.
    """
    lines = context.splitlines()
    if 0 <= error_line_index < len(lines):
        lines[error_line_index] = colored(
            lines[error_line_index], 'yellow', attrs=['bold'])
    return '\n'.join(lines)


def save_to_json(error_info, output_path):
    """
    Saves the parsed error information to a JSON file.
    Args:
        error_info (dict): The parsed error information.
        output_path (str): Path to the output JSON file.
    """
    with open(output_path, 'w') as f:
        json.dump(error_info, f, indent=4)
    print(colored(f"\nError information saved to {output_path}", 'green'))


def generate_error_tree(error_info, output_path, format='png', view=False, save=True):
    """
    Generates a graphical representation of the error hierarchy using Graphviz.
    Args:
        error_info (dict): The parsed error information.
        output_path (str): Path to save the graph visualization.
        format (str): The format of the output file (e.g., 'png', 'pdf').
        view (bool): Whether to open the generated file with the default viewer.
        save (bool): Whether to save the generated file.
    """
    dot = graphviz.Digraph(comment='C++ Template Error Tree')
    main_error = error_info["main_error"]

    if main_error:
        main_label = f"Main Error: {main_error['message']}"
        if 'file' in main_error:
            main_label += f"\nFile: {main_error['file']}:{main_error['line']}"
        dot.node('main', main_label)

    for idx, nested in enumerate(error_info['nested_errors'], 1):
        dot.node(f'nested{idx}', nested)
        dot.edge('main', f'nested{idx}')

    if save:
        try:
            dot.render(output_path, view=view, format=format)
            print(colored(f"\nError tree saved as {
                  output_path}.{format}", 'green'))
        except graphviz.backend.execute.ExecutableNotFound as e:
            print(colored(f"Graphviz executable not found: {e}", 'red'))
            print(colored(
                "Please ensure Graphviz is installed and added to your system's PATH.", 'red'))
    elif view:
        try:
            dot.view()
        except graphviz.backend.execute.ExecutableNotFound as e:
            print(colored(f"Graphviz executable not found: {e}", 'red'))
            print(colored(
                "Please ensure Graphviz is installed and added to your system's PATH.", 'red'))


def download_file(url, output_path):
    """
    Downloads a file from a given URL.
    Args:
        url (str): The URL to download the file from.
        output_path (str): The path to save the downloaded file.
    """
    try:
        response = requests.get(url)
        response.raise_for_status()
        with open(output_path, 'wb') as f:
            f.write(response.content)
        print(colored(f"Downloaded file from {url} to {output_path}", 'green'))
    except requests.exceptions.RequestException as e:
        print(colored(f"Error downloading file: {e}", 'red'))


def decompress_file(input_path, output_path):
    """
    Decompresses a gzip file.
    Args:
        input_path (str): The path to the gzip file.
        output_path (str): The path to save the decompressed file.
    """
    try:
        with gzip.open(input_path, 'rb') as f_in:
            with open(output_path, 'wb') as f_out:
                f_out.write(f_in.read())
        print(colored(f"Decompressed file from {
              input_path} to {output_path}", 'green'))
    except (OSError, IOError) as e:
        print(colored(f"Error decompressing file: {e}", 'red'))


def main():
    """
    Main function that handles command-line arguments and executes the appropriate actions
    based on the provided options.
    """
    parser = argparse.ArgumentParser(description="C++ Template Error Analyzer")
    parser.add_argument('file', metavar='FILE', type=str,
                        help="Path to the error log file")
    parser.add_argument('--output', metavar='OUTPUT', type=str,
                        default="parsed_error.json", help="Path to save parsed error info")
    parser.add_argument('--graph', metavar='GRAPH', type=str,
                        default="error_tree", help="Filename for error tree graph")
    parser.add_argument('--compiler', metavar='COMPILER', type=str, choices=[
                        'gcc', 'clang', 'msvc'], default='gcc', help="Compiler type (gcc, clang, msvc)")
    parser.add_argument('--context', metavar='CONTEXT', type=int, default=3,
                        help="Number of context lines to extract around error line")
    parser.add_argument('--download', metavar='URL', type=str,
                        help="URL to download the error log file")
    parser.add_argument('--decompress', metavar='GZIP_FILE',
                        type=str, help="Path to the gzip file to decompress")
    parser.add_argument('--format', metavar='FORMAT', type=str, default='png',
                        help="Format of the output graph file (e.g., 'png', 'pdf')")
    parser.add_argument('--view', action='store_true',
                        help="Whether to open the generated graph file with the default viewer")
    parser.add_argument('--no-save', action='store_true',
                        help="Whether to skip saving the generated graph file")
    args = parser.parse_args()

    # If the user provides a URL, download the error log
    if args.download:
        download_file(args.download, args.file)

    # If the user provides a gzip file, decompress it
    if args.decompress:
        decompress_file(args.decompress, args.file)

    # Ensure that the provided error log file exists
    error_file = Path(args.file)
    if not error_file.exists():
        print(colored(f"Error: The file {args.file} does not exist.", 'red'))
        return

    # Read the error message from the file
    try:
        with open(args.file, 'r') as f:
            error_message = f.read()
    except (OSError, IOError) as e:
        print(colored(f"Error reading file {args.file}: {e}", 'red'))
        return

    # Parse the error message and format the output
    parsed_error = parse_cpp_template_error(
        error_message, compiler=args.compiler)
    format_error(parsed_error)

    # Extract and display code context if available
    main_error = parsed_error.get('main_error')
    if main_error and 'file' in main_error:
        file_path = main_error['file']
        line_number = int(main_error['line'])
        context = extract_code_context(
            file_path, line_number, context_lines=args.context)
        if context:
            print(colored("\nCode Context:", 'red'))
            print(context)

    # Save the parsed error information to a JSON file
    save_to_json(parsed_error, args.output)

    # Generate an error tree visualization
    generate_error_tree(parsed_error, args.graph,
                        format=args.format, view=args.view, save=not args.no_save)


if __name__ == "__main__":
    main()
